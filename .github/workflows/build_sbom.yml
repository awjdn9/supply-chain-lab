# This workflow builds the Docker image, generates an SBOM, and signs the image.
name: Build, SBOM, and Sign

# Trigger the workflow on push events to the main branch
on:
  push:
    branches:
      - main

jobs:
  build-sbom-sign:
    # Use the latest Ubuntu runner provided by GitHub Actions.
    runs-on: ubuntu-latest

    permissions:
      contents: read # Allow reading repository contents
      packages: write # Allow writing to GitHub Packages (for image push)
      id-token: write # Allow OpenID Connect (OIDC) token issuance for Sigstore

    steps:
    - name: Checkout code
      # Action to check out your repository code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      # Action to set up Buildx, a Docker component for building images
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      # Log in to the GitHub Container Registry where we will push the image
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and Push Docker Image
      # Build and immediately push the tagged image to GitHub Container Registry
      id: build-image # Give this step an ID to reference its outputs
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true # Push the image to the registry
        tags: |
          ghcr.io/${{ github.repository }}:latest
          ghcr.io/${{ github.repository }}:${{ github.sha }}
  
    - name: Install Cosign
      # Install the Cosign tool
      uses: sigstore/cosign-installer@v3.5.0
      with:
        cosign-release: 'v2.2.3' # Specify a Cosign version
  
    - name: Sign the Container Image with Cosign
      # Use Cosign to sign the image we just pushed
      # We use keyless signing (no need to manage keys manually)
      # The COSIGN_EXPERIMENTAL environment variable is needed for keyless signing in some versions
      env:
        COSIGN_EXPERIMENTAL: "true"
      run: |
        cosign sign ghcr.io/${{ github.repository }}@${{ steps.build-image.outputs.digest }}  

    - name: Pull Docker Image for Analysis
      # Explicitly pull the image using the authenticated Docker daemon on the runner
      # This ensures the image is available locally for Syft to analyze
      run: docker pull ghcr.io/${{ github.repository }}@${{ steps.build-image.outputs.digest }}

    - name: Generate SBOM with Syft
      # Run Syft as a Docker container to analyze our image
      # We output the SBOM in CycloneDX JSON format
      # The SBOM file is saved as sbom.json
      # Mount the Docker socket to allow Syft (running in a container) to access the Docker daemon on the runner
      # Mount the workspace to save the SBOM file to the runner's filesystem
      run: |
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          -v ${{ github.workspace }}:/workspace \
          anchore/syft:latest \
          ghcr.io/${{ github.repository }}@${{ steps.build-image.outputs.digest }} \ # Analyze the image now available locally
          -o cyclonedx-json=/workspace/sbom.json

    - name: Upload SBOM artifact
      # Upload the generated sbom.json file as a workflow artifact
      # This makes the SBOM available for download from the GitHub Actions run page
      uses: actions/upload-artifact@v4
      with:
        name: sbom
        path: sbom.json