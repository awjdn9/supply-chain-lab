# This workflow builds the Docker image, generates an SBOM, and signs the image.
name: Build, SBOM, and Sign

# Trigger the workflow on push events to the main branch
on:
  push:
    branches:
      - main

jobs:
  build-sbom-sign: # Renamed the job for clarity
    runs-on: ubuntu-latest

    permissions:
      contents: read # Allow reading repository contents
      packages: write # Allow writing to GitHub Packages (for image push)
      id-token: write # Allow OpenID Connect (OIDC) token issuance for Sigstore

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    - name: Log in to GitHub Container Registry
      # Log in to the GitHub Container Registry where we will push the image
      uses: docker/login-action@v3
      with:
        registry: ghcr.io
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}

    - name: Build and Push Docker Image
      # Build and immediately push the tagged image to GitHub Container Registry
      id: build-image # Give this step an ID to reference its outputs
      uses: docker/build-push-action@v5
      with:
        context: .
        push: true # Push the image to the registry
        tags: |
          ghcr.io/${{ github.repository }}:latest
          ghcr.io/${{ github.repository }}:${{ github.sha }}

    - name: Install Cosign
      # Install the Cosign tool
      uses: sigstore/cosign-installer@v3.5.0
      with:
        cosign-release: 'v2.2.3' # Specify a Cosign version

    - name: Sign the Container Image with Cosign
      # Use Cosign to sign the image we just pushed
      # We use keyless signing (no need to manage keys manually)
      # The COSIGN_EXPERIMENTAL environment variable is needed for keyless signing in some versions
      env:
        COSIGN_EXPERIMENTAL: "true"
      run: |
        cosign sign ghcr.io/${{ github.repository }}@${{ steps.build-image.outputs.digest }}

    - name: Pull Docker Image for Analysis
      # Explicitly pull the image using the authenticated Docker daemon on the runner
      # This ensures the image is available locally for Syft to analyze
      run: docker pull ghcr.io/${{ github.repository }}@${{ steps.build-image.outputs.digest }}

    - name: Generate SBOM with Syft
      # Run Syft as a Docker container to analyze our image
      # Mount the Docker socket to allow Syft access to the daemon
      # Analyze the image and print SBOM to standard output (simplified for debugging)
      run: |
        docker run --rm \
          -v /var/run/docker.sock:/var/run/docker.sock \
          anchore/syft:latest \
          ghcr.io/${{ github.repository }}@${{ steps.build-image.outputs.digest }} # Analyze the image and print to stdout

    # Removed the Upload SBOM artifact step for this simplified test
    # - name: Upload SBOM artifact
    #   uses: actions/upload-artifact@v4
    #   with:
    #     name: sbom
    #     path: sbom.json